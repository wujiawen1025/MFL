/*
========================================================================================================================
**【文件描述】                                        【文件描述】                                        【文件描述】**
========================================================================================================================
**    文件名称：CommonLib.c 
**
**    功能描述: 主要包含一些通用的功能，如crc校验，字符/16进制转换等。
**
**    公    司：                                                                                                        
**
**    项目名称：                                                                                                        
**
**    平台信息：                                                                                                        
**
**    作    者：Hzy                                                                                                     
**
**    其他说明:                                                                                                        
**
**    修改记录:  --------------------------------------------------------------
**               2015.08
**               完成 V1.0 版本
**
========================================================================================================================
========================================================================================================================
*/

/*
========================================================================================================================
* 【文件包含】                                         【文件包含】                                          【文件包含】
========================================================================================================================
*/
#include "CommonLib.h"


/*
========================================================================================================================
**               临界区处理函数
**
** 注意：临界区处理的两个函数要根据实际的CPU进行移植
** 
========================================================================================================================
*/

static uint8_t   CriticalNesting;   /*临界区嵌套*/ 

/*
************************************************************************************************************************
* 函数名称 : Critical_Enter                                                                                                         
* 功能描述 : 进入临界区                                                                                                         
* 输入参数 : 无                                                                                                         
* 返回参数 : 无                                                                                                         
* 补充说明 : 无                                                                                                         
************************************************************************************************************************
*/
void Critical_Enter(void)
{
  if(0 == CriticalNesting)
  {
    BSP_DisInttrupt();
  }
  CriticalNesting++;    
}

/*
************************************************************************************************************************
* 函数名称 : Critical_Exit                                                                                                         
* 功能描述 : 退出临界区                                                                                                         
* 输入参数 : 无                                                                                                         
* 返回参数 : 无                                                                                                         
* 补充说明 : 无                                                                                                         
************************************************************************************************************************
*/
void Critical_Exit(void)
{
  if(CriticalNesting > 0)
  {
    CriticalNesting--;
    if (0 == CriticalNesting)
    {
      BSP_EnInttrupt();
    }
  }
}


/*
========================================================================================================================
**               调试信息 等 的跟踪输出
**
========================================================================================================================
*/
#define LOG_BUF_SIZE  256           

typedef struct
{
  uint8_t           Buf[LOG_BUF_SIZE];  /*使用FIFO进行管理*/
  uint16_t          In;
  uint16_t          Out;
  uint16_t          Len;
}Log_t;


#define  LOG_TERMINAL(x, l)    BSP_UART_TxData(BSP_UART_Port0, x, l) /*定义输出的终端为串口输出*/
#define  LOG_OUT_OK            BSP_UART_TxState_Idle


static Log_t Log;

int  Log_OutPutChar(int ch)
{
  Log.Len++;
  Log.Buf[Log.In++] = ch; 
  if(Log.In > (LOG_BUF_SIZE-1))
  {
    Log.In = 0;
  }
  return ch;
}

void  Log_OutPut(void)
{
  uint16_t TxLen;

  if(0 == Log.Len)
  {
    return;
  }

  if((Log.Out + Log.Len) < (LOG_BUF_SIZE))
  {
    TxLen = Log.Len;
  }
  else
  {
    TxLen = LOG_BUF_SIZE - Log.Out;
  }
  
  if(LOG_OUT_OK == LOG_TERMINAL(&Log.Buf[Log.Out], TxLen))
  {
    Log.Out += TxLen;
    if(Log.Out > (LOG_BUF_SIZE-1))
    {
      Log.Out = 0;
    }
    Log.Len -= TxLen;
  }
}


/**
  * @brief  Retarget printf to uart. 重定位printf的输出到串口
  * @param  IAR:Character to be sent.KEIL:Character to be sent.
  * @retval Character to be sent
  */

#if defined ( __CC_ARM   )      /* RealView Compiler */

struct __FILE {
    int handle;                 /* Add whatever you need here */
};
FILE __stdout;
FILE __stdin;
int fputc(int ch, FILE * f)

#elif defined ( __ICCARM__ )    /*IAR Compiler */

int putchar(int ch)

#endif

{
    return (Log_OutPutChar(ch));
}



/*
========================================================================================================================
**               字符 -- 16进制转换 
**
========================================================================================================================
*/
static const uint8_t  HexToAsciiTab[] =
{
  '0', '1', '2', '3', '4', '5', '6', '7', 
  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};


uint8_t HexToAscii(uint8_t hex)
{
  return HexToAsciiTab[hex];
}



uint16_t HexArrayToAscii(uint8_t *d, uint8_t *s, uint16_t size)
{
  uint8_t i;

  for(i=0; i<size; i++)
  {
    *d++ = HexToAsciiTab[(*s>>4)];
    *d++ = HexToAsciiTab[(*s&0x0f)];
    s++;
  }

  return (size*2);
}


uint16_t AsciiToHexArray(uint8_t *d, uint8_t *s, uint16_t size)
{
  uint8_t ch, i;
   
  size >>= 1;
  for(i=0; i<size; i++)
  {
    ch = *s++; 
    if((ch>='0') && (ch<='9'))
    {
      *d = (ch-'0') << 4;
    }
    else if((ch>='A') && (ch<='F'))
    {
      *d = (ch-55) << 4;
    }
    else if((ch>='a') && (ch<='f'))
    {
      *d = ch-'a'+10;
    }
    else
    {
      return 0;
    }  

    ch = *s++;
    if((ch>='0') && (ch<='9'))
    {
      *d += (ch-'0');
    }
    else if((ch>='A') && (ch<='F'))
    {
      *d += (ch-55);
    }
    else if((ch>='a') && (ch<='f'))
    {
      *d += ch-'a'+10;
    }
    else
    {
      return 0;
    }
    d++;
  }

  return size;  
}



/*
========================================================================================================================
**               crc16半字查表法
**
========================================================================================================================
*/
static const uint16_t CRC16_HalfWordTab[16] =
{
  0x0000, 0x1021, 0x2042, 0x3063, 
  0x4084, 0x50a5, 0x60c6, 0x70e7, 
  0x8108, 0x9129, 0xa14a, 0xb16b, 
  0xc18c, 0xd1ad, 0xe1ce, 0xf1ef
};


/*
************************************************************************************************************************
* 函数名称 : CRC16_Cal                                                                                                         
* 功能描述 : 计算CRC16                                                                                                  
* 输入参数 : pdata -- 指向要计算的数据
             len   -- 要计算的长度
             crc   -- 计算初值
* 返回参数 : 计算后的CRC值
* 补充说明 : 无                                                                                                         
************************************************************************************************************************
*/
uint16_t CRC16_Cal(uint8_t *pdata, uint32_t len, uint16_t crc) 
{
  uint8_t crc_H4;

  while(len--) 
  {
    crc_H4 = (uint8_t)(crc>>12);   /* 暂存CRC的高四位 */
    crc <<= 4;                     /* CRC左移4位，相当于取CRC的低12位）*/
    crc ^= CRC16_HalfWordTab[ crc_H4 ^ (*pdata >> 4)];    /* CRC的高4位和本字节的前半字节相加后查表计算CRC，然后加上上一次CRC的余数 */

    crc_H4 = (uint8_t)(crc>>12);   /* 暂存CRC的高4位 */
    crc <<= 4;                     /* CRC左移4位， 相当于CRC的低12位） */
    crc ^= CRC16_HalfWordTab[crc_H4 ^ (*pdata&0x0f)];       /* CRC的高4位和本字节的后半字节相加后查表计算CRC，然后再加上上一次CRC的余数 */
    pdata++;
  }

  return(crc);
}


/*
************************************************************************************************************************
* 函数名称 : CRC16_Check                                                                                                         
* 功能描述 : 检查crc是否正确                                                                                        
* 输入参数 : pdata -- 指向要计算的数据
             len   -- 数据的长度，最后两个字节为数据包收到的crc
* 返回参数 : CORRECT -- crc正确
*            ERROR   -- crc错误
* 补充说明 : 无                                                                                                         
************************************************************************************************************************
*/
uint8_t CRC16_Check(uint8_t *pdata, uint32_t len) 
{
  uint16_t crc;

  crc = pdata[len-2];
  crc |= (pdata[len-1] << 8);
  
  return (crc == CRC16_Cal(pdata, len-2, 0)) ? CORRECT : ERROR;
}


/*
========================================================================================================================
**               累加和校验
**
========================================================================================================================
*/
/*
************************************************************************************************************************
* 函数名称 : CumulativeSum_Cal                                                                                                         
* 功能描述 : 计算累加和                                                                                                
* 输入参数 : pdata -- 指向要计算的数据
             len   -- 要计算的长度
* 返回参数 : 计算后的累加和
* 补充说明 : 无                                                                                                         
************************************************************************************************************************
*/
uint8_t CumulativeSum_Cal(uint8_t *pdata, uint32_t len) 
{
  uint8_t sum;
  
  sum = 0;
  while(len--) 
  {
    sum += *pdata++;
  }  
  return sum;
}

/*
************************************************************************************************************************
* 函数名称 : CumulativeSum_Check                                                                                                         
* 功能描述 : 检查累加和是否正确                                                                                        
* 输入参数 : pdata -- 指向要计算的数据
             len   -- 数据的长度，最后1个字节为数据包收到的累加和
* 返回参数 : CORRECT -- crc正确
*            ERROR   -- crc错误
* 补充说明 : 无                                                                                                         
************************************************************************************************************************
*/
uint8_t CumulativeSum_Check(uint8_t *pdata, uint32_t len) 
{
  uint8_t sum;
  
  sum = pdata[len-1];
  
  return (sum == CumulativeSum_Cal(pdata, len-1)) ? CORRECT : ERROR;
}


/*
========================================================================================================================
**             大小端字节数据反转
** 说明：大端格式 -- 低地址存放高字节数据，高地址存放低字节数据。
**       小端格式 -- 低地址存放低字节数据，高地址存放高字节数据。      
**
========================================================================================================================
*/
/*
************************************************************************************************************************
* 函数名称 : Swap2Byte                                                                                                         
* 功能描述 : 反转2字节的数据                                                                                                    
* 输入参数 : Val -- 要反转的数据
* 返回参数 : 反转字节后的数据  
* 补充说明 : 无                                                                                                         
************************************************************************************************************************
*/
uint16_t Swap2Byte(uint16_t Val)
{
  return ( ((Val & 0xff)   << 8) | 
           ((Val & 0xff00) >> 8) );
}

/*
************************************************************************************************************************
* 函数名称 : Swap4Byte                                                                                                         
* 功能描述 : 反转4字节的数据                                                                                                    
* 输入参数 : Val -- 要反转的数据
* 返回参数 : 反转字节后的数据  
* 补充说明 : 无                                                                                                         
************************************************************************************************************************
*/
uint32_t Swap4Byte(uint32_t Val)
{
  return ( ((Val & 0xff)         << 24) |
           ((Val & 0xff00)       << 8)  |
           ((Val & 0xff0000UL)   >> 8)  |
           ((Val & 0xff000000UL) >> 24) );
}

/*
========================================================================================================================
**             折半查找算法
**
========================================================================================================================
*/

/*
************************************************************************************************************************
* 函数名称 : BinarySearch                                                                                                         
* 功能描述 : 折半查找算法                                                                                            
* 输入参数 : SearchID     -- 要查找的数据
*            TabNum       -- 要查找的表格的条目数量
*            pGetMatchID  -- 函数指针，指向的函数作用：返回表格条目中 要搜索的数据     
* 返回参数 : INDEX_NO_MATCH -- 无匹配的内容。
*            其他值         -- 匹配的索引位置       
* 补充说明 : 无                                                                                                         
************************************************************************************************************************
*/
uint16_t BinarySearch(uint16_t SearchID,  uint16_t TabItemNum, uint16_t (*pGetMatchID)(uint16_t index))
{
  uint16_t high, low, mid;
  uint16_t Index;
  

  low = 0;
  high = TabItemNum - 1;
  Index = INDEX_NO_MATCH; /*先假设不匹配*/ 
  while (low <= high)
  {
    mid = (low + high) >> 1;
    if(SearchID == pGetMatchID(mid))
    {
      Index = mid;        /*找到目标*/
      break;
    }
    else if(SearchID > pGetMatchID(mid))
    {
      low = mid + 1;
    }
    else
    {
      if(mid > 0)
      {
        high = mid - 1;  /*还能够往低端继续查找*/
      }
      else
      {
        break;           /*没找到，跳出*/
      }
    }
  }
  
  return Index;  
}

/*
========================================================================================================================
**             暂停功能 处理
*
* 使用说明： 假设有 A B C D 四个功能，且这四个分别处于不同的层，不同的模块。 
*            A可被 B C D 暂停。
*   
*            一般思路是： if((B) || (C) || (D))
*                         { 
*                           暂停 A
*                         }
*                         else
*                         {
*                           解除暂停A
*                         }
*
*            该方法将所有的判断条件汇总于一处来判断。
*            但由于 这四个分别处于不同的层，不同的模块。 
*            这种方法会提高模块间的耦合，甚至要跨层次。因此使用如下方法：
*            if(B)         if(C)         if(D)                                 
*            {             {             {                               
*              暂停 A        暂停 A        暂停 A                                 
*            }             }             }                
*            else          else          else                                         
*            {             {             {                                     
*              解除暂停A     解除暂停A     解除暂停A                                                     
*            }             }             }                                               
*            
*          每个模块独立地对A进行暂停相关操作。各个模块的暂停操作互不影响。
*          因此，对暂停的操作使用 “嵌套“的感念。
*          例如： B 要对A 打开暂停，则由变量OnOff保证B对A的暂停打开操作只执行一次。
*                 只有 执行关闭暂停后，才可再次执行 打开暂停操作。
*          该方法的优点：降低耦合，每个模块互不干涉。
*                  缺点：每个暂停操作要多增加一个 静态 OnOff 变量来记录暂停操作的状态。
**
========================================================================================================================
*/
/*
************************************************************************************************************************
* 函数名称 : PAUSE_ON                                                                                                         
* 功能描述 : 暂停 打开                                                                                                  
* 输入参数 : pOnOff   -- 标识是否执行了暂停打开动作，
*                         保证打开动作只执行一次。  
*             ValidBit -- pOnOff的有效位，用该位来记录操作
*             pPauseOn -- 暂停打开动作执行函数 
* 返回参数 : 无
* 补充说明 : 无                                                                                                         
************************************************************************************************************************
*/
void PAUSE_ON(uint8_t *pOnOff, uint8_t ValidBit, void(*pPauseOn)())
{
  ValidBit = (ValidBit>7) ? 7:ValidBit;

  if(0 == (*pOnOff & (1<<ValidBit)))
  {
    if(pPauseOn != NULL)
    {
      pPauseOn();
      *pOnOff |= 1<<ValidBit;
    }
  }
}

/*
************************************************************************************************************************
* 函数名称 : PAUSE_OFF                                                                                                         
* 功能描述 : 暂停 关闭                                                                                               
* 输入参数 : pOnOff    -- 标识是否执行了暂停关闭动作，
*                          保证关闭动作只执行一次。  
*            ValidBit  -- pOnOff的有效位，用该位来记录操作
*            pPauseOff -- 暂停关闭动作执行函数 
* 返回参数 : 无
* 补充说明 : 无                                                                                                         
************************************************************************************************************************
*/
void PAUSE_OFF(uint8_t *pOnOff, uint8_t ValidBit, void(*pPauseOff)())
{
  ValidBit = (ValidBit>7) ? 7:ValidBit;

  if((*pOnOff & (1<<ValidBit)) != 0)
  {
    if(pPauseOff != NULL)
    {
      pPauseOff();
      *pOnOff &= ~(1<<ValidBit);
    }
  }
}
